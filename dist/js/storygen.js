// Generated by Haxe 4.0.5
(function ($hx_exports, $global) { "use strict";
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	matched(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
}
EReg.__name__ = "EReg";
Object.assign(EReg.prototype, {
	__class__: EReg
});
class HxOverrides {
	static cca(s,index) {
		var x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static iter(a) {
		return { cur : 0, arr : a, hasNext : function() {
			return this.cur < this.arr.length;
		}, next : function() {
			return this.arr[this.cur++];
		}};
	}
}
HxOverrides.__name__ = "HxOverrides";
Math.__name__ = "Math";
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( e ) {
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			return null;
		}
	}
	static fields(o) {
		var a = [];
		if(o != null) {
			var hasOwnProperty = Object.prototype.hasOwnProperty;
			for( var f in o ) {
			if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
				a.push(f);
			}
			}
		}
		return a;
	}
}
Reflect.__name__ = "Reflect";
class Std {
	static parseInt(x) {
		if(x != null) {
			var _g = 0;
			var _g1 = x.length;
			while(_g < _g1) {
				var i = _g++;
				var c = x.charCodeAt(i);
				if(c <= 8 || c >= 14 && c != 32 && c != 45) {
					var v = parseInt(x, (x[(i + 1)]=="x" || x[(i + 1)]=="X") ? 16 : 10);
					if(isNaN(v)) {
						return null;
					} else {
						return v;
					}
				}
			}
		}
		return null;
	}
	static random(x) {
		if(x <= 0) {
			return 0;
		} else {
			return Math.floor(Math.random() * x);
		}
	}
}
Std.__name__ = "Std";
class StringTools {
	static isSpace(s,pos) {
		var c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		var l = s.length;
		var r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		var l = s.length;
		var r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
}
StringTools.__name__ = "StringTools";
class _$UInt_UInt_$Impl_$ {
	static toFloat(this1) {
		var int = this1;
		if(int < 0) {
			return 4294967296.0 + int;
		} else {
			return int + 0.0;
		}
	}
}
_$UInt_UInt_$Impl_$.__name__ = "_UInt.UInt_Impl_";
class dropecho_storygen_Functions {
	static set(name,func) {
		var _this = dropecho_storygen_Functions.funcs;
		if(__map_reserved[name] != null) {
			_this.setReserved(name,func);
		} else {
			_this.h[name] = func;
		}
	}
	static get(name) {
		var _this = dropecho_storygen_Functions.funcs;
		if(__map_reserved[name] != null) {
			return _this.getReserved(name);
		} else {
			return _this.h[name];
		}
	}
}
$hx_exports["Functions"] = dropecho_storygen_Functions;
dropecho_storygen_Functions.__name__ = "dropecho.storygen.Functions";
class dropecho_storygen__$Generator_AbsMap_$Impl_$ {
	static _new(s) {
		var this1 = s;
		return this1;
	}
	static fromDynamic(d) {
		var _g = new haxe_ds_StringMap();
		var _g1 = 0;
		var _g2 = Reflect.fields(d);
		while(_g1 < _g2.length) {
			var f = _g2[_g1];
			++_g1;
			var value = Reflect.field(d,f);
			if(__map_reserved[f] != null) {
				_g.setReserved(f,value);
			} else {
				_g.h[f] = value;
			}
		}
		var map = _g;
		return dropecho_storygen__$Generator_AbsMap_$Impl_$._new(map);
	}
	static toMap(this1) {
		return this1;
	}
	static isMap(this1) {
		var type = js_Boot.getClass(this1);
		if(type != null) {
			return type.__name__ == "haxe.ds.StringMap";
		} else {
			return false;
		}
	}
}
dropecho_storygen__$Generator_AbsMap_$Impl_$.__name__ = "dropecho.storygen._Generator.AbsMap_Impl_";
class dropecho_storygen_Generator {
	constructor(grammars) {
		this.memory = new haxe_ds_StringMap();
		this.random = new seedyrng_Random();
		this.matcher = new EReg("(#.*?#)","");
		this.grammars = dropecho_storygen__$Generator_AbsMap_$Impl_$.isMap(grammars) ? dropecho_storygen__$Generator_AbsMap_$Impl_$.toMap(grammars) : dropecho_storygen__$Generator_AbsMap_$Impl_$.toMap(dropecho_storygen__$Generator_AbsMap_$Impl_$.fromDynamic(grammars));
	}
	getSeed() {
		return haxe__$Int64_Int64_$Impl_$.toString(this.random.get_seed());
	}
	mergeGrammar(grammars) {
		var g = dropecho_storygen__$Generator_AbsMap_$Impl_$.isMap(grammars) ? grammars : dropecho_storygen__$Generator_AbsMap_$Impl_$.fromDynamic(grammars);
		var e = new haxe_iterators_MapKeyValueIterator(dropecho_storygen__$Generator_AbsMap_$Impl_$.toMap(g));
		while(e.hasNext()) {
			var e1 = e.next();
			var key = e1.key;
			var value = e1.value;
			var _this = this.grammars;
			if(__map_reserved[key] != null) {
				_this.setReserved(key,value);
			} else {
				_this.h[key] = value;
			}
		}
	}
	inMemory(symbol) {
		var _this = this.memory;
		if(__map_reserved[symbol] != null) {
			return _this.existsReserved(symbol);
		} else {
			return _this.h.hasOwnProperty(symbol);
		}
	}
	expand(token) {
		var tmp;
		if(!token.isMemorized) {
			var symbol = token.symbol;
			var _this = this.memory;
			tmp = __map_reserved[symbol] != null ? _this.existsReserved(symbol) : _this.h.hasOwnProperty(symbol);
		} else {
			tmp = true;
		}
		if(tmp) {
			var sym = token.memSymbol != null ? token.memSymbol : token.symbol;
			var _this1 = this.memory;
			if(__map_reserved[sym] != null ? _this1.existsReserved(sym) : _this1.h.hasOwnProperty(sym)) {
				var _this2 = this.memory;
				if(__map_reserved[sym] != null) {
					return _this2.getReserved(sym);
				} else {
					return _this2.h[sym];
				}
			}
		}
		var s = token.symbol;
		if(token.isFunction) {
			var func = dropecho_storygen_Functions.get(token.symbol);
			if(func != null) {
				return func(this,token.functionArgs);
			} else {
				throw new js__$Boot_HaxeError("\n          No function \"" + s + "\" exists on the function object.\n          Double check spelling (#random(5,10)#) or add function to Functions.\n          example: \n          ``` storygen.Functions.set(\"myFunc\", (s:String) => return \"hi\");```\n        ");
			}
		}
		var _this3 = this.grammars;
		var grammar = __map_reserved[s] != null ? _this3.getReserved(s) : _this3.h[s];
		if(grammar == null) {
			throw new js__$Boot_HaxeError("\n        No symbol \"" + s + "\" exists in your grammar.\n        Ensure the object/map contains an array for this or\n        that you have stored this in memory.\n        example: ``` var grammar = {" + s + ": [\"choice1\", \"choice2\"]}; ```\n        example: ``` var grammar = {\"example\": [\"#" + s + ":some_other#\"]}; ```\n      ");
		}
		if(grammar.length <= 0) {
			throw new js__$Boot_HaxeError("\n        No choices in grammar for symbol \"" + s + "\", has 0 elements.\n        Try adding some.\n        example: ``` var grammar = {" + s + ": [\"choice1\", \"choice2\"]}; ```\n      ");
		}
		var pos = this.random.randomInt(0,grammar.length - 1);
		var expanded = grammar[pos];
		return expanded;
	}
	doTransforms(s,token) {
		var _g = 0;
		var _g1 = token.transforms;
		while(_g < _g1.length) {
			var transform = _g1[_g];
			++_g;
			var t = dropecho_storygen_Transforms.get(transform);
			if(t == null) {
				throw new js__$Boot_HaxeError("\n              No transform \"" + transform + "\" exists on the transforms object.\n              Double check spelling (#sym.capitalize#) or add transform to Transforms.\n              example: \n              ``` storygen.Transforms.set(\"myTransform\", (s:String) => return \"hi\");```\n            ");
			} else {
				s = t(s);
			}
		}
		return s;
	}
	parse(string) {
		var tempMemory = [];
		while(this.matcher.match(string)) {
			var match = this.matcher.matched(1);
			var token = new dropecho_storygen_Token(match);
			var expanded = this.expand(token);
			if(!token.isValid) {
				continue;
			}
			expanded = this.parse(expanded);
			if(token.isTransformed) {
				expanded = this.doTransforms(expanded,token);
			}
			if(token.isMemorized) {
				var key = token.memSymbol;
				var _this = this.memory;
				if(__map_reserved[key] != null) {
					_this.setReserved(key,expanded);
				} else {
					_this.h[key] = expanded;
				}
				if(token.memSymbol.charAt(0) == "_") {
					tempMemory.push(token.memSymbol);
				}
			}
			if(token.isSilent) {
				string = string.replace(this.matcher.r,"");
			} else {
				string = string.replace(this.matcher.r,expanded);
			}
		}
		var _g = 0;
		while(_g < tempMemory.length) {
			var t = tempMemory[_g];
			++_g;
			this.memory.remove(t);
		}
		return string;
	}
	run(from,seed) {
		if(seed != null) {
			this.random.set_seed(haxe_Int64Helper.fromFloat(parseFloat(seed)));
		}
		var out;
		if(from.charAt(0) != "#") {
			out = this.parse("#" + from + "#");
		}
		out = this.parse(from);
		var _this = this.memory;
		_this.h = { };
		_this.rh = null;
		return out;
	}
	runAdvanced(from,seed) {
		if(seed != null) {
			this.random.set_seed(haxe_Int64Helper.fromFloat(parseFloat(seed)));
		}
		var output = this.parse(from);
		var _g = new haxe_ds_StringMap();
		var _g1 = new haxe_iterators_MapKeyValueIterator(this.memory);
		while(_g1.hasNext()) {
			var _g2 = _g1.next();
			var k = _g2.key;
			var v = _g2.value;
			if(__map_reserved[k] != null) {
				_g.setReserved(k,v);
			} else {
				_g.h[k] = v;
			}
		}
		var memory = _g;
		var _this = this.memory;
		_this.h = { };
		_this.rh = null;
		return { seed : this.getSeed(), output : output, memory : memory.h};
	}
	static configFromJson(json) {
		var json1 = JSON.parse(json);
		var _g = new haxe_ds_StringMap();
		var _g1 = 0;
		var _g2 = Reflect.fields(json1);
		while(_g1 < _g2.length) {
			var f = _g2[_g1];
			++_g1;
			var value = Reflect.field(json1,f);
			if(__map_reserved[f] != null) {
				_g.setReserved(f,value);
			} else {
				_g.h[f] = value;
			}
		}
		return _g;
	}
}
$hx_exports["Generator"] = dropecho_storygen_Generator;
dropecho_storygen_Generator.__name__ = "dropecho.storygen.Generator";
Object.assign(dropecho_storygen_Generator.prototype, {
	__class__: dropecho_storygen_Generator
});
class dropecho_storygen_Token {
	constructor(text) {
		this.isFunctionCall = new EReg("(.*)\\((.*)\\)","");
		this.shouldBeTransformed = new EReg("(.*?)\\.(.*)","");
		this.shouldBeMemorized = new EReg("(.*):(.*)","");
		this.shouldBeSilent = new EReg("\\[(.*?)\\]","");
		this.isValidToken = new EReg("#(.*?)#","");
		this.transforms = [];
		this.functionArgs = [];
		this.origText = text;
		this.isValid = this.isValidToken.match(text);
		if(this.isValid) {
			var token = this.isValidToken.matched(1);
			if(this.isSilent = this.shouldBeSilent.match(token)) {
				token = this.shouldBeSilent.matched(1);
			}
			if(this.isMemorized = this.shouldBeMemorized.match(token)) {
				this.memSymbol = this.shouldBeMemorized.matched(1);
				token = this.shouldBeMemorized.matched(2);
			}
			if(this.isTransformed = this.shouldBeTransformed.match(token)) {
				token = this.shouldBeTransformed.matched(1);
				this.transforms = this.shouldBeTransformed.matched(2).split(".");
			}
			if(this.isFunction = this.isFunctionCall.match(token)) {
				token = this.isFunctionCall.matched(1);
				var _this = this.isFunctionCall.matched(2).split(",");
				var result = new Array(_this.length);
				var _g = 0;
				var _g1 = _this.length;
				while(_g < _g1) {
					var i = _g++;
					result[i] = StringTools.trim(_this[i]);
				}
				var _g2 = [];
				var _g11 = 0;
				var _g21 = result;
				while(_g11 < _g21.length) {
					var v = _g21[_g11];
					++_g11;
					if(v != null && v != "") {
						_g2.push(v);
					}
				}
				this.functionArgs = _g2;
			}
			this.symbol = token;
		}
	}
}
dropecho_storygen_Token.__name__ = "dropecho.storygen.Token";
Object.assign(dropecho_storygen_Token.prototype, {
	__class__: dropecho_storygen_Token
});
class dropecho_storygen_Transforms {
	static isVowel(s) {
		var vowels = "aeiou";
		return vowels.indexOf(s.charAt(0)) != -1;
	}
	static capitalize(s) {
		var chars = s.split("");
		var f = chars.shift();
		return f.toUpperCase() + chars.join("");
	}
	static a(s) {
		if(dropecho_storygen_Transforms.isVowel(s.charAt(0))) {
			return "an " + s;
		} else {
			return "a " + s;
		}
	}
	static pluralize(s) {
		var end;
		switch(s.charAt(s.length - 1)) {
		case "h":
			end = "es";
			break;
		case "y":
			s = HxOverrides.substr(s,0,s.length - 1);
			end = "ies";
			break;
		default:
			end = "s";
		}
		return "" + s + end;
	}
	static get(name) {
		var _this = dropecho_storygen_Transforms.userTransforms;
		if(__map_reserved[name] != null ? _this.existsReserved(name) : _this.h.hasOwnProperty(name)) {
			var _this1 = dropecho_storygen_Transforms.userTransforms;
			if(__map_reserved[name] != null) {
				return _this1.getReserved(name);
			} else {
				return _this1.h[name];
			}
		}
		return Reflect.field(dropecho_storygen_Transforms,name);
	}
	static set(name,trans) {
		var _this = dropecho_storygen_Transforms.userTransforms;
		if(__map_reserved[name] != null) {
			_this.setReserved(name,trans);
		} else {
			_this.h[name] = trans;
		}
	}
}
$hx_exports["Transforms"] = dropecho_storygen_Transforms;
dropecho_storygen_Transforms.__name__ = "dropecho.storygen.Transforms";
class haxe__$Int32_Int32_$Impl_$ {
	static ucompare(a,b) {
		if(a < 0) {
			if(b < 0) {
				return ~b - ~a | 0;
			} else {
				return 1;
			}
		}
		if(b < 0) {
			return -1;
		} else {
			return a - b | 0;
		}
	}
}
haxe__$Int32_Int32_$Impl_$.__name__ = "haxe._Int32.Int32_Impl_";
class haxe__$Int64_Int64_$Impl_$ {
	static toString(this1) {
		var i = this1;
		var b_high = 0;
		var b_low = 0;
		if(i.high == b_high && i.low == b_low) {
			return "0";
		}
		var str = "";
		var neg = false;
		if(i.high < 0) {
			neg = true;
		}
		var this2 = new haxe__$Int64__$_$_$Int64(0,10);
		var ten = this2;
		while(true) {
			var b_high1 = 0;
			var b_low1 = 0;
			if(!(i.high != b_high1 || i.low != b_low1)) {
				break;
			}
			var r = haxe__$Int64_Int64_$Impl_$.divMod(i,ten);
			if(r.modulus.high < 0) {
				var x = r.modulus;
				var high = ~x.high;
				var low = ~x.low + 1 | 0;
				if(low == 0) {
					var ret = high++;
					high = high | 0;
				}
				var this_high = high;
				var this_low = low;
				str = this_low + str;
				var x1 = r.quotient;
				var high1 = ~x1.high;
				var low1 = ~x1.low + 1 | 0;
				if(low1 == 0) {
					var ret1 = high1++;
					high1 = high1 | 0;
				}
				var this3 = new haxe__$Int64__$_$_$Int64(high1,low1);
				i = this3;
			} else {
				str = r.modulus.low + str;
				i = r.quotient;
			}
		}
		if(neg) {
			str = "-" + str;
		}
		return str;
	}
	static divMod(dividend,divisor) {
		if(divisor.high == 0) {
			switch(divisor.low) {
			case 0:
				throw new js__$Boot_HaxeError("divide by zero");
			case 1:
				var this1 = new haxe__$Int64__$_$_$Int64(dividend.high,dividend.low);
				var this2 = new haxe__$Int64__$_$_$Int64(0,0);
				return { quotient : this1, modulus : this2};
			}
		}
		var divSign = dividend.high < 0 != divisor.high < 0;
		var modulus;
		if(dividend.high < 0) {
			var high = ~dividend.high;
			var low = ~dividend.low + 1 | 0;
			if(low == 0) {
				var ret = high++;
				high = high | 0;
			}
			var this3 = new haxe__$Int64__$_$_$Int64(high,low);
			modulus = this3;
		} else {
			var this4 = new haxe__$Int64__$_$_$Int64(dividend.high,dividend.low);
			modulus = this4;
		}
		if(divisor.high < 0) {
			var high1 = ~divisor.high;
			var low1 = ~divisor.low + 1 | 0;
			if(low1 == 0) {
				var ret1 = high1++;
				high1 = high1 | 0;
			}
			var this5 = new haxe__$Int64__$_$_$Int64(high1,low1);
			divisor = this5;
		} else {
			divisor = divisor;
		}
		var this6 = new haxe__$Int64__$_$_$Int64(0,0);
		var quotient = this6;
		var this7 = new haxe__$Int64__$_$_$Int64(0,1);
		var mask = this7;
		while(!(divisor.high < 0)) {
			var v = haxe__$Int32_Int32_$Impl_$.ucompare(divisor.high,modulus.high);
			var cmp = v != 0 ? v : haxe__$Int32_Int32_$Impl_$.ucompare(divisor.low,modulus.low);
			var b = 1;
			b &= 63;
			if(b == 0) {
				var this8 = new haxe__$Int64__$_$_$Int64(divisor.high,divisor.low);
				divisor = this8;
			} else if(b < 32) {
				var this9 = new haxe__$Int64__$_$_$Int64(divisor.high << b | divisor.low >>> 32 - b,divisor.low << b);
				divisor = this9;
			} else {
				var this10 = new haxe__$Int64__$_$_$Int64(divisor.low << b - 32,0);
				divisor = this10;
			}
			var b1 = 1;
			b1 &= 63;
			if(b1 == 0) {
				var this11 = new haxe__$Int64__$_$_$Int64(mask.high,mask.low);
				mask = this11;
			} else if(b1 < 32) {
				var this12 = new haxe__$Int64__$_$_$Int64(mask.high << b1 | mask.low >>> 32 - b1,mask.low << b1);
				mask = this12;
			} else {
				var this13 = new haxe__$Int64__$_$_$Int64(mask.low << b1 - 32,0);
				mask = this13;
			}
			if(cmp >= 0) {
				break;
			}
		}
		while(true) {
			var b_high = 0;
			var b_low = 0;
			if(!(mask.high != b_high || mask.low != b_low)) {
				break;
			}
			var v1 = haxe__$Int32_Int32_$Impl_$.ucompare(modulus.high,divisor.high);
			if((v1 != 0 ? v1 : haxe__$Int32_Int32_$Impl_$.ucompare(modulus.low,divisor.low)) >= 0) {
				var this14 = new haxe__$Int64__$_$_$Int64(quotient.high | mask.high,quotient.low | mask.low);
				quotient = this14;
				var high2 = modulus.high - divisor.high | 0;
				var low2 = modulus.low - divisor.low | 0;
				if(haxe__$Int32_Int32_$Impl_$.ucompare(modulus.low,divisor.low) < 0) {
					var ret2 = high2--;
					high2 = high2 | 0;
				}
				var this15 = new haxe__$Int64__$_$_$Int64(high2,low2);
				modulus = this15;
			}
			var b2 = 1;
			b2 &= 63;
			if(b2 == 0) {
				var this16 = new haxe__$Int64__$_$_$Int64(mask.high,mask.low);
				mask = this16;
			} else if(b2 < 32) {
				var this17 = new haxe__$Int64__$_$_$Int64(mask.high >>> b2,mask.high << 32 - b2 | mask.low >>> b2);
				mask = this17;
			} else {
				var this18 = new haxe__$Int64__$_$_$Int64(0,mask.high >>> b2 - 32);
				mask = this18;
			}
			var b3 = 1;
			b3 &= 63;
			if(b3 == 0) {
				var this19 = new haxe__$Int64__$_$_$Int64(divisor.high,divisor.low);
				divisor = this19;
			} else if(b3 < 32) {
				var this20 = new haxe__$Int64__$_$_$Int64(divisor.high >>> b3,divisor.high << 32 - b3 | divisor.low >>> b3);
				divisor = this20;
			} else {
				var this21 = new haxe__$Int64__$_$_$Int64(0,divisor.high >>> b3 - 32);
				divisor = this21;
			}
		}
		if(divSign) {
			var high3 = ~quotient.high;
			var low3 = ~quotient.low + 1 | 0;
			if(low3 == 0) {
				var ret3 = high3++;
				high3 = high3 | 0;
			}
			var this22 = new haxe__$Int64__$_$_$Int64(high3,low3);
			quotient = this22;
		}
		if(dividend.high < 0) {
			var high4 = ~modulus.high;
			var low4 = ~modulus.low + 1 | 0;
			if(low4 == 0) {
				var ret4 = high4++;
				high4 = high4 | 0;
			}
			var this23 = new haxe__$Int64__$_$_$Int64(high4,low4);
			modulus = this23;
		}
		return { quotient : quotient, modulus : modulus};
	}
}
haxe__$Int64_Int64_$Impl_$.__name__ = "haxe._Int64.Int64_Impl_";
class haxe__$Int64__$_$_$Int64 {
	constructor(high,low) {
		this.high = high;
		this.low = low;
	}
}
haxe__$Int64__$_$_$Int64.__name__ = "haxe._Int64.___Int64";
Object.assign(haxe__$Int64__$_$_$Int64.prototype, {
	__class__: haxe__$Int64__$_$_$Int64
});
class haxe_Int64Helper {
	static fromFloat(f) {
		if(isNaN(f) || !isFinite(f)) {
			throw new js__$Boot_HaxeError("Number is NaN or Infinite");
		}
		var noFractions = f - f % 1;
		if(noFractions > 9007199254740991) {
			throw new js__$Boot_HaxeError("Conversion overflow");
		}
		if(noFractions < -9007199254740991) {
			throw new js__$Boot_HaxeError("Conversion underflow");
		}
		var this1 = new haxe__$Int64__$_$_$Int64(0,0);
		var result = this1;
		var neg = noFractions < 0;
		var rest = neg ? -noFractions : noFractions;
		var i = 0;
		while(rest >= 1) {
			var curr = rest % 2;
			rest /= 2;
			if(curr >= 1) {
				var a_high = 0;
				var a_low = 1;
				var b = i;
				b &= 63;
				var b1;
				if(b == 0) {
					var this2 = new haxe__$Int64__$_$_$Int64(a_high,a_low);
					b1 = this2;
				} else if(b < 32) {
					var this3 = new haxe__$Int64__$_$_$Int64(a_high << b | a_low >>> 32 - b,a_low << b);
					b1 = this3;
				} else {
					var this4 = new haxe__$Int64__$_$_$Int64(a_low << b - 32,0);
					b1 = this4;
				}
				var high = result.high + b1.high | 0;
				var low = result.low + b1.low | 0;
				if(haxe__$Int32_Int32_$Impl_$.ucompare(low,result.low) < 0) {
					var ret = high++;
					high = high | 0;
				}
				var this5 = new haxe__$Int64__$_$_$Int64(high,low);
				result = this5;
			}
			++i;
		}
		if(neg) {
			var high1 = ~result.high;
			var low1 = ~result.low + 1 | 0;
			if(low1 == 0) {
				var ret1 = high1++;
				high1 = high1 | 0;
			}
			var this6 = new haxe__$Int64__$_$_$Int64(high1,low1);
			result = this6;
		}
		return result;
	}
}
haxe_Int64Helper.__name__ = "haxe.Int64Helper";
class haxe_ds_StringMap {
	constructor() {
		this.h = { };
	}
	get(key) {
		if(__map_reserved[key] != null) {
			return this.getReserved(key);
		}
		return this.h[key];
	}
	setReserved(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	getReserved(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	existsReserved(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	remove(key) {
		if(__map_reserved[key] != null) {
			key = "$" + key;
			if(this.rh == null || !this.rh.hasOwnProperty(key)) {
				return false;
			}
			delete(this.rh[key]);
			return true;
		} else {
			if(!this.h.hasOwnProperty(key)) {
				return false;
			}
			delete(this.h[key]);
			return true;
		}
	}
	keys() {
		return HxOverrides.iter(this.arrayKeys());
	}
	arrayKeys() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
}
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
Object.assign(haxe_ds_StringMap.prototype, {
	__class__: haxe_ds_StringMap
});
class haxe_io_Bytes {
}
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
class haxe_iterators_MapKeyValueIterator {
	constructor(map) {
		this.map = map;
		this.keys = map.keys();
	}
	hasNext() {
		return this.keys.hasNext();
	}
	next() {
		var key = this.keys.next();
		return { value : this.map.get(key), key : key};
	}
}
haxe_iterators_MapKeyValueIterator.__name__ = "haxe.iterators.MapKeyValueIterator";
Object.assign(haxe_iterators_MapKeyValueIterator.prototype, {
	__class__: haxe_iterators_MapKeyValueIterator
});
class js__$Boot_HaxeError extends Error {
	constructor(val) {
		super();
		this.val = val;
		if(Error.captureStackTrace) {
			Error.captureStackTrace(this,js__$Boot_HaxeError);
		}
	}
}
js__$Boot_HaxeError.__name__ = "js._Boot.HaxeError";
Object.assign(js__$Boot_HaxeError.prototype, {
	__class__: js__$Boot_HaxeError
});
class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array)) {
			return Array;
		} else {
			var cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			var name = js_Boot.__nativeClassName(o);
			if(name != null) {
				return js_Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __nativeClassName(o) {
		var name = js_Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
js_Boot.__name__ = "js.Boot";
class seedyrng_Random {
	constructor(seed,generator) {
		if(seed == null) {
			var this1 = new haxe__$Int64__$_$_$Int64(seedyrng_Random.randomSystemInt(),seedyrng_Random.randomSystemInt());
			seed = this1;
		}
		if(generator == null) {
			generator = new seedyrng_Xorshift128Plus();
		}
		this.generator = generator;
		this.set_seed(seed);
	}
	get_seed() {
		return this.generator.get_seed();
	}
	set_seed(value) {
		return this.generator.set_seed(value);
	}
	get_usesAllBits() {
		return this.generator.get_usesAllBits();
	}
	nextInt() {
		return this.generator.nextInt();
	}
	nextFullInt() {
		if(this.generator.get_usesAllBits()) {
			return this.generator.nextInt();
		} else {
			var num1 = this.generator.nextInt();
			var num2 = this.generator.nextInt();
			num2 = num2 >>> 16 | num2 << 16;
			return num1 ^ num2;
		}
	}
	random() {
		var upper = this.nextFullInt() & 2097151;
		var lower = this.nextFullInt();
		var b = upper * Math.pow(2,32);
		var floatNum = _$UInt_UInt_$Impl_$.toFloat(lower) + b;
		var result = floatNum * Math.pow(2,-53);
		return result;
	}
	randomInt(lower,upper) {
		return Math.floor(this.random() * (upper - lower + 1)) + lower;
	}
	static randomSystemInt() {
		var value = Std.random(255) << 24 | Std.random(255) << 16 | Std.random(255) << 8 | Std.random(255);
		return value;
	}
}
seedyrng_Random.__name__ = "seedyrng.Random";
Object.assign(seedyrng_Random.prototype, {
	__class__: seedyrng_Random
});
class seedyrng_Xorshift128Plus {
	constructor() {
		this._currentAvailable = false;
		var this1 = new haxe__$Int64__$_$_$Int64(0,1);
		this.set_seed(this1);
	}
	get_usesAllBits() {
		return false;
	}
	get_seed() {
		return this._seed;
	}
	set_seed(value) {
		var b_high = 0;
		var b_low = 0;
		if(value.high != b_high || value.low != b_low) {
			value = value;
		} else {
			var this1 = new haxe__$Int64__$_$_$Int64(0,1);
			value = this1;
		}
		this._seed = value;
		this._state0 = value;
		this._state1 = seedyrng_Xorshift128Plus.SEED_1;
		this._currentAvailable = false;
		return value;
	}
	stepNext() {
		var x = this._state0;
		var y = this._state1;
		this._state0 = y;
		var b = 23;
		b &= 63;
		var b1;
		if(b == 0) {
			var this1 = new haxe__$Int64__$_$_$Int64(x.high,x.low);
			b1 = this1;
		} else if(b < 32) {
			var this2 = new haxe__$Int64__$_$_$Int64(x.high << b | x.low >>> 32 - b,x.low << b);
			b1 = this2;
		} else {
			var this3 = new haxe__$Int64__$_$_$Int64(x.low << b - 32,0);
			b1 = this3;
		}
		var this4 = new haxe__$Int64__$_$_$Int64(x.high ^ b1.high,x.low ^ b1.low);
		x = this4;
		var a_high = x.high ^ y.high;
		var a_low = x.low ^ y.low;
		var b2 = 17;
		b2 &= 63;
		var b3;
		if(b2 == 0) {
			var this5 = new haxe__$Int64__$_$_$Int64(x.high,x.low);
			b3 = this5;
		} else if(b2 < 32) {
			var this6 = new haxe__$Int64__$_$_$Int64(x.high >> b2,x.high << 32 - b2 | x.low >>> b2);
			b3 = this6;
		} else {
			var this7 = new haxe__$Int64__$_$_$Int64(x.high >> 31,x.high >> b2 - 32);
			b3 = this7;
		}
		var a_high1 = a_high ^ b3.high;
		var a_low1 = a_low ^ b3.low;
		var b4 = 26;
		b4 &= 63;
		var b5;
		if(b4 == 0) {
			var this8 = new haxe__$Int64__$_$_$Int64(y.high,y.low);
			b5 = this8;
		} else if(b4 < 32) {
			var this9 = new haxe__$Int64__$_$_$Int64(y.high >> b4,y.high << 32 - b4 | y.low >>> b4);
			b5 = this9;
		} else {
			var this10 = new haxe__$Int64__$_$_$Int64(y.high >> 31,y.high >> b4 - 32);
			b5 = this10;
		}
		var this11 = new haxe__$Int64__$_$_$Int64(a_high1 ^ b5.high,a_low1 ^ b5.low);
		this._state1 = this11;
		var a = this._state1;
		var high = a.high + y.high | 0;
		var low = a.low + y.low | 0;
		if(haxe__$Int32_Int32_$Impl_$.ucompare(low,a.low) < 0) {
			var ret = high++;
			high = high | 0;
		}
		var this12 = new haxe__$Int64__$_$_$Int64(high,low);
		this._current = this12;
	}
	nextInt() {
		if(this._currentAvailable) {
			this._currentAvailable = false;
			return this._current.low;
		} else {
			this.stepNext();
			this._currentAvailable = true;
			return this._current.high;
		}
	}
}
seedyrng_Xorshift128Plus.__name__ = "seedyrng.Xorshift128Plus";
Object.assign(seedyrng_Xorshift128Plus.prototype, {
	__class__: seedyrng_Xorshift128Plus
});
String.prototype.__class__ = String;
String.__name__ = "String";
Array.__name__ = "Array";
var __map_reserved = {};
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
js_Boot.__toStr = ({ }).toString;
dropecho_storygen_Functions.funcs = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	{
		var value = function(gen,args) {
			var min = Std.parseInt(args[0]);
			var max = Std.parseInt(args[1]);
			var int = gen.random.randomInt(min,max);
			if(int == null) {
				return "null";
			} else {
				return "" + int;
			}
		};
		if(__map_reserved["random"] != null) {
			_g.setReserved("random",value);
		} else {
			_g.h["random"] = value;
		}
	}
	{
		var value1 = function(gen1,args1) {
			var symbol = args1.shift();
			var _this = gen1.memory;
			var parsed = __map_reserved[symbol] != null ? _this.getReserved(symbol) : _this.h[symbol];
			if(parsed != null) {
				var _g1 = 0;
				while(_g1 < args1.length) {
					var a = args1[_g1];
					++_g1;
					var split = a.split("=>");
					if(split[0] == parsed) {
						return "#" + split[1] + "#";
					}
				}
			}
			return "";
		};
		if(__map_reserved["switch"] != null) {
			_g.setReserved("switch",value1);
		} else {
			_g.h["switch"] = value1;
		}
	}
	$r = _g;
	return $r;
}(this));
dropecho_storygen_Transforms.userTransforms = new haxe_ds_StringMap();
seedyrng_Xorshift128Plus.SEED_1 = (function($this) {
	var $r;
	var this1 = new haxe__$Int64__$_$_$Int64(842650776,685298713);
	$r = this1;
	return $r;
}(this));
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
